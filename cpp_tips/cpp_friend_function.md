# C++

## friend キーワード

### 解説

C++における`friend`キーワードは、あるクラスや関数が別のクラスのプライベート（またはプロテクテッド）メンバーにアクセスできるようにするために使用されます。これにより、通常はアクセスできないプライベートメンバーへのアクセスを許可することができます。

### `friend`キーワードの基本的な使い方

1. **クラス内での`friend`宣言**: クラスAの内部で、別のクラスBや関数を`friend`として宣言することができます。これにより、クラスBやその関数はクラスAのプライベートメンバーにアクセスできるようになります。
2. **相互のアクセス許可**: 二つのクラスがお互いのプライベートメンバーにアクセスする必要がある場合、相互に`friend`として宣言することができます。

### コード例

以下は、`friend`キーワードの簡単な使用例です。この例では、クラス`Box`がプライベート変数を持ち、関数`displayBox`が`friend`として宣言されており、`Box`のプライベートメンバーにアクセスしています。

```c++
#include <iostream>

// クラスの宣言
class Box {
private:
    int width;

public:
    // explicitは付けた方が良いという話がC++の本に書いてあった。
    // これは付けないと暗黙的な変換が行われるので、それを回避するためである。
    // 例えば、Box b = 10; と書いた場合、10がBoxのコンストラクタに渡されて、
    // Box b = Box(10); と同じ意味になる。
    // 一方でexplicitを付けると、コンストラクタの引数に10が渡されることはなくなる
    // そのため、Box b = 10; と書いた場合、コンパイルエラーになる
    explicit Box() : width(0) { }  // コンストラクタ
    friend void displayBox(Box& b); // friend関数の宣言
};

// friend関数の定義
void displayBox(Box& b) {
    // プライベートメンバにアクセスできる
    std::cout << "Box width: " << b.width << std::endl;
}

// メイン関数
int main() {
    Box myBox;
    // friend関数を呼び出す
    displayBox(myBox);
    return 0;
}        
```

この例では、`displayBox`関数は`Box`クラスのプライベートメンバーである`width`にアクセスしています。通常、プライベートメンバーはクラスの外部からアクセスできませんが、`friend`キーワードによって特別なアクセス権が与えられています。

`friend`キーワードは慎重に使用する必要があります。過度に使用すると、プログラムのカプセル化（隠蔽）の原則を損なう可能性があります。通常は、特定の関数やクラスが密接に関連していて、他の方法でアクセスできない場合に限って使用されるべきです。

### friend関数を用いるデザインパターン(オペレータオーバーロード)

C++において`friend`キーワードを用いる一般的なデザインパターンの一つは「オペレータオーバーロード」です。特に、ストリーム挿入演算子(`<<`)やストリーム抽出演算子(`>>`)のオーバーロードにおいてよく使用されます。これにより、ユーザー定義型のオブジェクトを標準入出力ストリーム（例えば`std::cout`や`std::cin`）に直接挿入または抽出することが可能になります。

### オペレータオーバーロードと`friend`キーワード

クラス内のプライベートメンバーにアクセスする必要がある場合、オペレータをクラスの`friend`関数として定義することができます。これは特に、クラスが内部状態をプライベートに保持している場合に便利です。

```cpp
#include <iostream>

class MyClass {
private:
    int value;
public:
    MyClass(int v) : value(v) { }
    // friend関数としてオペレータ<<をオーバーロードする
    friend std::ostream& operator<<(std::ostream& os, const MyClass& obj);
};
    
// ユーザー定義型オブジェクトを標準入出力ストリームに直接挿入、または抽
// することが出来るようになる
// オペレータ<<の定義
std::ostream& operator<<(std::ostream& os, const MyClass& obj) {
    os << obj.value; // プライベートメンバにアクセスする
    return os;
}


int main() {
    MyClass myObject(10);
    // オペレータ<<を使用
    std::cout << "myObject: " << myObject << std::endl;
    return 0;
}                  
```

この例では、`MyClass`オブジェクトを`std::cout`を使って直接出力できます。`operator<<`関数は`MyClass`のプライベートメンバー`value`にアクセスするため、`friend`として定義されています。

このようなパターンは、クラスの内部データを外部に出力する場合や、クラスのインスタンスをストリームに直接挿入できるようにする場合に有用です。ただし、`friend`キーワードの使用は最小限に抑えるべきであり、カプセル化を損なわない範囲で使用することが推奨されます。